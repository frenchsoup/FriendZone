<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FriendZone Fantasy Football</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link rel="stylesheet" href="/styles.css">
</head>
<body class="bg-gray-800 text-gray-100 font-sans">
  <div id="root"></div>
  <script type="text/babel">
    window.AppState = {
      rules: { sections: [] },
      setRules: () => {},
      modalState: { isOpen: false, type: '', data: null },
      setModalState: () => {},
      updateData: async () => true,
    };

    const calculateKeeperCost = (draftCost, tag, keeperName) => {
      if (keeperName === '' && draftCost === 0) return 0;
      if (draftCost === 0 && !tag) return 5;
      if (draftCost === 0 && tag) return 0;
      if (tag) return Math.round(draftCost);
      return Math.round(draftCost * 1.1 + 5);
    };

    const App = () => {
      const [keepers, setKeepers] = React.useState({
        2022: [], 2023: [], 2024: [], 2025: []
      });
      const [prizes, setPrizes] = React.useState({});
      const [locks, setLocks] = React.useState({});
      const [rules, setRules] = React.useState({ sections: [] });
      const [payouts, setPayouts] = React.useState([]);
      const [selectedYear, setSelectedYear] = React.useState('2025');
      const [isAdminAuthenticated, setIsAdminAuthenticated] = React.useState(false);
      const [view, setView] = React.useState('home');
      const [isNavOpen, setIsNavOpen] = React.useState(false);
      const [isLoading, setIsLoading] = React.useState(true);
      const [pendingChanges, setPendingChanges] = React.useState({ keepers: {}, prizes: {} });

      React.useEffect(() => {
        window.AppState.setRules = setRules;
        window.AppState.setModalState = setModalState;
        window.AppState.updateData = updateData;
      }, []);

      const initializeData = async () => {
        setIsLoading(true);
        try {
          const baseUrl = '/.netlify/functions/get-data?filename=';
          const keeperYears = ['2022', '2023', '2024', '2025'];
          const prizeYears = ['2023', '2024', '2025'];
          const promises = [];

          keeperYears.forEach(year => {
            promises.push(
              fetch(`${baseUrl}keepers_${year}.json`)
                .then(response => response.json())
                .then(data => {
                  setKeepers(prev => ({
                    ...prev,
                    [year]: Array.isArray(data) && data.length > 0 ? data.map(team => ({
                      ...team,
                      draftCost1: Math.round(team.draftCost1 || 0),
                      draftCost2: Math.round(team.draftCost2 || 0),
                      cost1: Math.round(calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)),
                      cost2: Math.round(calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2)),
                      remaining: 200 - (Math.round(calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)) + Math.round(calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2)))
                    })) : Array(12).fill().map((_, i) => ({
                      team: `Team ${i + 1}`,
                      keeper1: '', draftCost1: 0, tag1: false, cost1: 0,
                      keeper2: '', draftCost2: 0, tag2: false, cost2: 0,
                      remaining: 200,
                    }))
                  }));
                })
                .catch(() => {
                  setKeepers(prev => ({
                    ...prev,
                    [year]: Array(12).fill().map((_, i) => ({
                      team: `Team ${i + 1}`,
                      keeper1: '', draftCost1: 0, tag1: false, cost1: 0,
                      keeper2: '', draftCost2: 0, tag2: false, cost2: 0,
                      remaining: 200,
                    }))
                  }));
                })
            );
          });

          prizeYears.forEach(year => {
            promises.push(
              fetch(`${baseUrl}prizes_${year}.json`)
                .then(response => response.json())
                .then(data => {
                  setPrizes(prev => ({
                    ...prev,
                    [year]: data && (data.weeklyHighScores || data.survivor) ? data : {
                      weeklyHighScores: Array(14).fill().map((_, i) => ({ week: i + 1, team: '', total: '' })),
                      survivor: Array(12).fill().map((_, i) => i === 11 ? { week: 12, winner: '' } : { week: i + 1, eliminated: '' })
                    }
                  }));
                })
                .catch(() => {
                  setPrizes(prev => ({
                    ...prev,
                    [year]: {
                      weeklyHighScores: Array(14).fill().map((_, i) => ({ week: i + 1, team: '', total: '' })),
                      survivor: Array(12).fill().map((_, i) => i === 11 ? { week: 12, winner: '' } : { week: i + 1, eliminated: '' })
                    }
                  }));
                })
            );
          });

          promises.push(
            fetch(`${baseUrl}locks.json`)
              .then(response => response.json())
              .then(data => setLocks(data || { 2022: true, 2023: true, 2024: true, 2025: false }))
          );

          promises.push(
            fetch(`${baseUrl}rules.json`)
              .then(response => response.json())
              .then(data => setRules(data.sections ? data : { sections: [] }))
          );

          promises.push(
            fetch(`${baseUrl}payouts.json`)
              .then(response => response.json())
              .then(data => setPayouts(Array.isArray(data) ? data : []))
          );

          await Promise.all(promises);
        } finally {
          setIsLoading(false);
        }
      };

      const updateData = async (filename, data, action, indexData) => {
        try {
          const response = await fetch('/.netlify/functions/update-data', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file: filename, data, action, indexData }),
          });
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Update failed');
          }
          return true;
        } catch (error) {
          console.error('Update error:', error);
          return false;
        }
      };

      const handleKeeperChange = (year, index, field, value) => {
        if (locks[year]) return;
        setPendingChanges(prev => {
          const updatedPending = { ...prev, keepers: { ...prev.keepers, [year]: { ...prev.keepers[year] } } };
          updatedPending.keepers[year][index] = {
            ...updatedPending.keepers[year][index],
            ...keepers[year][index],
            [field]: field.includes('tag') ? value : field.includes('draftCost') ? (value === '' ? 0 : parseFloat(value)) : value,
          };
          const team = updatedPending.keepers[year][index];
          if ((team.draftCost1 === 0 && team.tag1) || (team.draftCost2 === 0 && team.tag2)) {
            alert('No player can be kept for $0 if tagged.');
            team[field.includes('tag') ? field : field.includes('draftCost') ? (field === 'draftCost1' ? 'tag1' : 'tag2') : field] = false;
          }
          team.cost1 = calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1);
          team.cost2 = calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2);
          team.remaining = 200 - (team.cost1 + team.cost2);
          if (team.remaining < 0) {
            alert('Total keeper cost exceeds $200 budget.');
            return prev;
          }
          return updatedPending;
        });
      };

      const handleSaveRow = async (year, index, payload) => {
        if (locks[year]) return;
        const result = await updateData(payload.file, payload.data, payload.action, payload.indexData);
        if (result) {
          setKeepers(prev => ({
            ...prev,
            [year]: prev[year].map((team, i) => (i === index ? payload.data : team)),
          }));
          setPendingChanges(prev => ({
            ...prev,
            keepers: { ...prev.keepers, [year]: { ...prev.keepers[year], [index]: {} } },
          }));
        } else {
          alert('Failed to save keeper changes');
        }
      };

      const handleWeeklyScoreChange = (year, index, field, value) => {
        if (!isAdminAuthenticated) return;
        setPendingChanges(prev => {
          const updatedPending = { ...prev, prizes: { ...prev.prizes, [year]: { ...prev.prizes[year], weeklyHighScores: [...(prev.prizes[year]?.weeklyHighScores || [])] } } };
          updatedPending.prizes[year].weeklyHighScores[index] = {
            ...updatedPending.prizes[year]?.weeklyHighScores[index] || prizes[year].weeklyHighScores[index],
            [field]: field === 'total' ? (value === '' ? '' : parseFloat(value)) : value,
          };
          return updatedPending;
        });
      };

      const handleWeeklyScoreSave = async (year, index, payload) => {
        if (!isAdminAuthenticated) return;
        const result = await updateData(payload.file, payload.data, payload.action);
        if (result) {
          setPrizes(prev => ({
            ...prev,
            [year]: payload.data,
          }));
          setPendingChanges(prev => ({
            ...prev,
            prizes: { ...prev.prizes, [year]: { ...prev.prizes[year], weeklyHighScores: [] } },
          }));
        } else {
          alert('Failed to save Weekly High Score');
        }
      };

      const handleSurvivorChange = (year, index, value) => {
        if (!isAdminAuthenticated) return;
        setPendingChanges(prev => {
          const updatedPending = { ...prev, prizes: { ...prev.prizes, [year]: { ...prev.prizes[year], survivor: [...(prev.prizes[year]?.survivor || [])] } } };
          updatedPending.prizes[year].survivor[index] = {
            ...updatedPending.prizes[year]?.survivor[index] || prizes[year].survivor[index],
            [index === 11 ? 'winner' : 'eliminated']: value,
          };
          return updatedPending;
        });
      };

      const handleSurvivorSave = async (year, index, payload) => {
        if (!isAdminAuthenticated) return;
        const result = await updateData(payload.file, payload.data, payload.action);
        if (result) {
          setPrizes(prev => ({
            ...prev,
            [year]: payload.data,
          }));
          setPendingChanges(prev => ({
            ...prev,
            prizes: { ...prev.prizes, [year]: { ...prev.prizes[year], survivor: [] } },
          }));
        } else {
          alert('Failed to save Survivor');
        }
      };

      const handleToggleLock = async (year, payload) => {
        if (!isAdminAuthenticated) return;
        const result = await updateData(payload.file, payload.data, payload.action);
        if (result) {
          setLocks(payload.data);
        } else {
          alert('Failed to toggle lock');
        }
      };

      const getRemainingTeams = (year, currentIndex = -1) => {
        const survivorTeams = prizes[year]?.survivor
          ?.filter((entry, index) => currentIndex === -1 || index <= currentIndex)
          .map(entry => entry.eliminated || entry.winner)
          .filter(team => team) || [];
        const defaultTeams = ['Team 1', 'Team 2', 'Team 3', 'Team 4', 'Team 5', 'Team 6', 'Team 7', 'Team 8', 'Team 9', 'Team 10', 'Team 11', 'Team 12'];
        return (keepers[year]?.length > 0
          ? keepers[year].map(team => team.team)
          : defaultTeams)
          .filter(team => team && !survivorTeams.includes(team))
          .sort();
      };

      const handleAdminLogin = (e) => {
        e.preventDefault();
        const password = e.target.querySelector('#password').value;
        if (password === 'friendzone2025') {
          setIsAdminAuthenticated(true);
          alert('Login successful!');
        } else {
          alert('Incorrect password');
        }
      };

      const handleLogout = () => {
        setIsAdminAuthenticated(false);
        alert('Logged out');
      };

      const handleRuleChange = (sectionIndex, itemIndex, field, value) => {
        if (!isAdminAuthenticated) return;
        const updatedRules = { ...rules };
        const item = updatedRules.sections[sectionIndex].items[itemIndex];
        if (typeof item === 'string') {
          updatedRules.sections[sectionIndex].items[itemIndex] = value;
        } else {
          if (field === 'text') {
            updatedRules.sections[sectionIndex].items[itemIndex].text = value;
          } else {
            updatedRules.sections[sectionIndex].items[itemIndex].subItems = value.split('\n').filter(line => line.trim());
          }
        }
        setRules(updatedRules);
      };

      const handleAddSection = () => {
        if (!isAdminAuthenticated) return;
        const updatedRules = { ...rules };
        updatedRules.sections.push({ title: 'New Section', items: ['New Rule'] });
        setRules(updatedRules);
        updateData('rules.json', updatedRules);
      };

      const handleAddRule = (sectionIndex) => {
        if (!isAdminAuthenticated) return;
        const updatedRules = { ...rules };
        updatedRules.sections[sectionIndex].items.push('New Rule');
        setRules(updatedRules);
        updateData('rules.json', updatedRules);
      };

      const handleSectionTitleChange = (sectionIndex, title) => {
        if (!isAdminAuthenticated) return;
        const updatedRules = { ...rules };
        updatedRules.sections[sectionIndex].title = title;
        setRules(updatedRules);
      };

      const handlePayoutChange = (index, field, value) => {
        if (!isAdminAuthenticated) return;
        const updatedPayouts = [...payouts];
        updatedPayouts[index] = { ...updatedPayouts[index], [field]: field === 'category' ? value : parseFloat(value) || 0 };
        setPayouts(updatedPayouts);
      };

      const handleAddPayout = () => {
        if (!isAdminAuthenticated) return;
        const updatedPayouts = [...payouts, { category: 'New Payout', percentage: 0, prize: 0 }];
        setPayouts(updatedPayouts);
        updateData('payouts.json', updatedPayouts);
      };

      const handleDeletePayout = (index) => {
        if (!isAdminAuthenticated) return;
        const updatedPayouts = payouts.filter((_, i) => i !== index);
        setPayouts(updatedPayouts);
        updateData('payouts.json', updatedPayouts);
      };

      React.useEffect(() => {
        initializeData();
      }, []);

      return (
        <div className="min-h-screen">
          {isLoading && <div className="text-center text-gray-300">Loading...</div>}
          <nav className="bg-gray-800 p-4 shadow-lg">
            <div className="flex justify-between items-center">
              <div className="text-teal-400 font-bold text-lg">FriendZone FF</div>
              <button
                className="md:hidden text-gray-300 focus:outline-none"
                onClick={() => setIsNavOpen(!isNavOpen)}
              >
                <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d={isNavOpen ? 'M6 18L18 6M6 6l12 12' : 'M4 6h16M4 12h16M4 18h16'} />
                </svg>
              </button>
            </div>
            <div className={`${isNavOpen ? 'block' : 'hidden'} md:flex md:space-x-4 mt-2 md:mt-0`}>
              <a href="#" onClick={() => { setView('home'); setIsNavOpen(false); }} className="block text-gray-300 hover:text-teal-400 py-1 md:py-0 transition-colors">Home</a>
              <a href="#" onClick={() => { setView('rules'); setIsNavOpen(false); }} className="block text-gray-300 hover:text-teal-400 py-1 md:py-0 transition-colors">Rules</a>
              <a href="#" onClick={() => { setView('payouts'); setIsNavOpen(false); }} className="block text-gray-300 hover:text-teal-400 py-1 md:py-0 transition-colors">Payouts</a>
              <a href="#" onClick={() => { setView('keepers'); setIsNavOpen(false); }} className="block text-gray-300 hover:text-teal-400 py-1 md:py-0 transition-colors">Keepers</a>
              <a href="#" onClick={() => { setView('prizes'); setIsNavOpen(false); }} className="block text-gray-300 hover:text-teal-400 py-1 md:py-0 transition-colors">Prizes</a>
              {isAdminAuthenticated && (
                <a href="#" onClick={() => { setView('admin'); setIsNavOpen(false); }} className="block text-gray-300 hover:text-teal-400 py-1 md:py-0 transition-colors">Admin</a>
              )}
              <div className="md:ml-4">
                {!isAdminAuthenticated ? (
                  <button onClick={() => { setView('admin'); setIsNavOpen(false); }} className="block text-gray-300 hover:text-teal-400 py-1 md:py-0 transition-colors">Login</button>
                ) : (
                  <button onClick={() => { handleLogout(); setIsNavOpen(false); }} className="block text-gray-300 hover:text-teal-400 py-1 md:py-0 transition-colors">Logout</button>
                )}
              </div>
            </div>
          </nav>
          <main className="px-4 sm:px-6 py-4">
            {view === 'home' && window.Home && <window.Home />}
            {view === 'rules' && window.Rules && <window.Rules
              rules={rules}
              setRules={setRules}
              isAdminAuthenticated={isAdminAuthenticated}
              updateData={updateData}
              handleRuleChange={handleRuleChange}
              handleAddSection={handleAddSection}
              handleAddRule={handleAddRule}
              handleSectionTitleChange={handleSectionTitleChange}
              setModalState={setModalState}
            />}
            {view === 'payouts' && window.Payouts && <window.Payouts
              payouts={payouts}
              setPayouts={setPayouts}
              isAdminAuthenticated={isAdminAuthenticated}
              updateData={updateData}
              handlePayoutChange={handlePayoutChange}
              handleAddPayout={handleAddPayout}
              handleDeletePayout={handleDeletePayout}
            />}
            {view === 'keepers' && window.Keepers && !isLoading && keepers[selectedYear]?.length && <window.Keepers
              keepers={keepers}
              locks={locks}
              selectedYear={selectedYear}
              setSelectedYear={setSelectedYear}
              isAdminAuthenticated={isAdminAuthenticated}
              pendingChanges={pendingChanges}
              handleKeeperChange={handleKeeperChange}
              handleSaveRow={handleSaveRow}
              handleToggleLock={handleToggleLock}
            />}
            {view === 'prizes' && window.Prizes && !isLoading && prizes[selectedYear]?.weeklyHighScores && prizes[selectedYear]?.survivor && <window.Prizes
              prizes={prizes}
              keepers={keepers}
              selectedYear={selectedYear}
              setSelectedYear={setSelectedYear}
              isAdminAuthenticated={isAdminAuthenticated}
              pendingChanges={pendingChanges}
              handleWeeklyScoreChange={handleWeeklyScoreChange}
              handleWeeklyScoreSave={handleWeeklyScoreSave}
              handleSurvivorChange={handleSurvivorChange}
              handleSurvivorSave={handleSurvivorSave}
              getRemainingTeams={getRemainingTeams}
            />}
            {view === 'admin' && window.Admin && <window.Admin handleAdminLogin={handleAdminLogin} />}
            <window.Modal />
          </main>
        </div>
      );
    };

    const checkComponentsLoaded = setInterval(() => {
      if (window.Home && window.Rules && window.Payouts && window.Keepers && window.Prizes && window.Admin && window.Modal) {
        clearInterval(checkComponentsLoaded);
        ReactDOM.render(<App />, document.getElementById('root'));
      }
    }, 100);
  </script>
  <script src="/sections/home.js" type="text/babel"></script>
  <script src="/sections/rules.js" type="text/babel"></script>
  <script src="/sections/payouts.js" type="text/babel"></script>
  <script src="/sections/keepers.js" type="text/babel"></script>
  <script src="/sections/prizes.js" type="text/babel"></script>
  <script src="/sections/admin.js" type="text/babel"></script>
  <script src="/sections/modal.js" type="text/babel"></script>
</body>
</html>