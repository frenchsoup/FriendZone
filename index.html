<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FriendZone Fantasy Football League</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/styles.css">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
</head>

<body class="bg-gray-900 text-gray-100">
  <div id="spinner-root">
    <div class="flex items-center justify-center min-h-screen" id="initial-spinner">
      <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-teal-500 border-b-4 border-gray-200"></div>
    </div>
  </div>
  <div id="root"></div>
  <script type="text/babel" src="/sections/modal.js"></script>
  <script type="text/babel" src="/sections/home.js"></script>
  <script type="text/babel" src="/sections/rules.js"></script>
  <script type="text/babel" src="/sections/payouts.js"></script>
  <script type="text/babel" src="/sections/keepers.js"></script>
  <script type="text/babel" src="/sections/prizes.js"></script>
  <script type="text/babel" src="/sections/admin.js"></script>
  <script type="text/babel" src="/sections/financials.js"></script>
  <script type="text/babel">
    // Remove initial spinner once React is ready
    document.addEventListener('DOMContentLoaded', () => {
      const spinner = document.getElementById('initial-spinner');
      if (spinner) spinner.style.display = 'block';
    });

    const App = () => {
      const [currentTab, setCurrentTab] = React.useState('home');
      const [adminPassword, setAdminPassword] = React.useState('');
      const [isAdminAuthenticated, setIsAdminAuthenticated] = React.useState(false);
      const [keepers, setKeepers] = React.useState({ 2022: [], 2023: [], 2024: [], 2025: [] });
      const [prizes, setPrizes] = React.useState({
        2023: { survivor: [], weeklyHighScores: [] },
        2024: { survivor: [], weeklyHighScores: [] },
        2025: {
          survivor: Array.from({ length: 12 }, (_, i) => i < 11 ? { week: i + 1, eliminated: '' } : { week: 12, winner: '' }),
          weeklyHighScores: Array.from({ length: 14 }, (_, i) => ({ week: i + 1, team: '', total: '' }))
        }
      });
      const [rules, setRules] = React.useState({ sections: [] });
      const [payouts, setPayouts] = React.useState([]);
      const [locks, setLocks] = React.useState({ 2022: false, 2023: false, 2024: false, 2025: false });
      const [selectedYear, setSelectedYear] = React.useState('2025');
      const [isSaving, setIsSaving] = React.useState(false);
      const [isMenuOpen, setIsMenuOpen] = React.useState(false);
      const [modalState, setModalState] = React.useState({ isOpen: false, type: '', data: null });
      const [pendingChanges, setPendingChanges] = React.useState({ 2022: {}, 2023: {}, 2024: {}, 2025: {} });
      const [loading, setLoading] = React.useState(true);
      const [yearlyAwards, setYearlyAwards] = React.useState({});
      const [leagueTeams, setLeagueTeams] = React.useState([]);

      const ADMIN_PASSWORD = 'friendzone2025';

      // Fetch data
      React.useEffect(() => {
        const fetchData = async () => {
          setLoading(true);
          const files = [
            { path: '/data/rules.json', setter: (data) => { setRules(data); window.AppState.rules = data; }, default: { sections: [] } },
            { path: '/data/payouts.json', setter: (data) => { setPayouts(data); window.AppState.payouts = data; }, default: [] },
            { path: '/data/yearlyawards.json', setter: (data) => { setYearlyAwards(data); window.AppState.yearlyAwards = data; }, default: {} },
            { path: '/data/league_teams.json', setter: (data) => { setLeagueTeams(data); window.AppState.leagueTeams = data; }, default: [] },
            { path: '/data/prizes_2023.json', setter: (data) => { setPrizes(prev => { const updated = { ...prev, 2023: data }; window.AppState.prizes = updated; return updated; }); }, default: { survivor: [], weeklyHighScores: [] } },
            { path: '/data/prizes_2024.json', setter: (data) => { setPrizes(prev => { const updated = { ...prev, 2024: data }; window.AppState.prizes = updated; return updated; }); }, default: { survivor: [], weeklyHighScores: [] } },
            { path: '/data/prizes_2025.json', setter: (data) => { setPrizes(prev => { const updated = { ...prev, 2025: data }; window.AppState.prizes = updated; return updated; }); }, default: { survivor: [], weeklyHighScores: [] } },
            {
              path: '/data/keepers_2022.json', setter: (data) => setKeepers(prev => ({
                ...prev, 2022: data.map(team => ({
                  ...team,
                  draftCost1: Math.round(team.draftCost1 || 0),
                  draftCost2: Math.round(team.draftCost2 || 0),
                  cost1: Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)),
                  cost2: Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2)),
                  remaining: 200 - (
                    Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)) +
                    Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2))
                  )
                }))
              })), default: []
            },
            {
              path: '/data/keepers_2023.json', setter: (data) => setKeepers(prev => ({
                ...prev, 2023: data.map(team => ({
                  ...team,
                  draftCost1: Math.round(team.draftCost1 || 0),
                  draftCost2: Math.round(team.draftCost2 || 0),
                  cost1: Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)),
                  cost2: Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2)),
                  remaining: 200 - (
                    Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)) +
                    Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2))
                  )
                }))
              })), default: []
            },
            {
              path: '/data/keepers_2024.json', setter: (data) => setKeepers(prev => ({
                ...prev, 2024: data.map(team => ({
                  ...team,
                  draftCost1: Math.round(team.draftCost1 || 0),
                  draftCost2: Math.round(team.draftCost2 || 0),
                  cost1: Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)),
                  cost2: Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2)),
                  remaining: 200 - (
                    Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)) +
                    Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2))
                  )
                }))
              })), default: []
            },
            {
              path: '/data/keepers_2025.json', setter: (data) => setKeepers(prev => ({
                ...prev, 2025: data.map(team => ({
                  ...team,
                  draftCost1: Math.round(team.draftCost1 || 0),
                  draftCost2: Math.round(team.draftCost2 || 0),
                  cost1: Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)),
                  cost2: Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2)),
                  remaining: 200 - (
                    Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)) +
                    Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2))
                  )
                }))
              })), default: []
            },
            { path: '/data/locks.json', setter: setLocks, default: { 2022: false, 2023: false, 2024: false, 2025: false } },
          ];
          for (const file of files) {
            try {
              const res = await fetch(file.path);
              if (res.ok) {
                const data = await res.json();
                file.setter(data);
              } else {
                file.setter(file.default);
                console.warn(`Failed to load ${file.path}. Using default value.`);
              }
            } catch (err) {
              file.setter(file.default);
              console.warn(`Error fetching ${file.path}:`, err);
            }
          }
          setLoading(false);
        };
        fetchData();
      }, []);

      // Share state and handlers globally
      window.AppState = {
        currentTab, setCurrentTab,
        adminPassword, setAdminPassword,
        isAdminAuthenticated, setIsAdminAuthenticated,
        keepers, setKeepers,
        prizes, setPrizes,
        rules, setRules,
        payouts, setPayouts,
        locks, setLocks,
        selectedYear, setSelectedYear,
        isMenuOpen, setIsMenuOpen,
        modalState, setModalState,
        pendingChanges, setPendingChanges,
        ADMIN_PASSWORD: 'friendzone2025',
        yearlyAwards, setYearlyAwards,
        leagueTeams, setLeagueTeams,
        // Team helpers: canonical mapping and lookups
        getTeamsForYear: (year) => {
          const y = Number(year);
          return (window.AppState.leagueTeams || []).filter(t => (t.years || []).map(Number).includes(y)).map(t => ({ id: t.id, team: t.team }));
        },
        getTeamById: (id) => (window.AppState.leagueTeams || []).find(t => t.id === id) || null,
        getTeamIdByName: (name) => {
          if (!name) return null;
          const found = (window.AppState.leagueTeams || []).find(t => String(t.team).toLowerCase() === String(name).toLowerCase());
          return found ? found.id : null;
        },
        normalizeTeamName: (name) => {
          if (!name) return '';
          const found = (window.AppState.leagueTeams || []).find(t => String(t.team).toLowerCase() === String(name).toLowerCase());
          return found ? found.team : String(name).trim();
        },
        calculateKeeperCost: (draftCost, tag, keeperName) => {
          if (keeperName === '' && draftCost === 0) return 0;
          if (draftCost === 0 && !tag) return 5;
          if (draftCost === 0 && tag) return 0;
          if (tag) return Math.round(draftCost);
          return Math.round(draftCost * 1.1 + 5);
        },
        updateData: async (file, data, action, index = null) => {
          try {
            setIsSaving(true);
            const res = await fetch('/.netlify/functions/update-data', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ file, data, action, index })
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}: ${await res.text()}`);
            return await res.json();
          } catch (err) {
            console.error('Error updating data:', err);
            alert('Failed to update data. Please try again.');
            return null;
          } finally {
            setIsSaving(false);
          }
        },
        normalizeNumberInput: (value) => {
          if (value === '' || value == null) return '';
          const strValue = String(value).replace(/^0+/, '');
          if (strValue === '') return '';
          const intValue = Math.round(parseFloat(strValue) || 0);
          return intValue.toString();
        },
        handleArrowKey: (e, year, index, field) => {
          if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            const currentValue = parseFloat(e.target.value) || 0;
            const newValue = e.key === 'ArrowUp' ? currentValue + 1 : Math.max(0, currentValue - 1);
            window.AppState.handleKeeperChange(year, index, field, newValue.toString());
          }
        },
        handleAdminLogin: (e) => {
          e.preventDefault();
          if (window.AppState.adminPassword === window.AppState.ADMIN_PASSWORD) {
            window.AppState.setIsAdminAuthenticated(true);
            window.AppState.setCurrentTab('home');
          } else {
            alert('Incorrect password');
          }
        },
        handleToggleLock: async (year) => {
          const updatedLocks = { ...window.AppState.locks, [year]: !window.AppState.locks[year] };
          const result = await window.AppState.updateData('locks.json', updatedLocks, 'update');
          if (result) {
            window.AppState.setLocks(updatedLocks);
            if (updatedLocks[year]) {
              window.AppState.setPendingChanges(prev => ({ ...prev, [year]: {} }));
            }
          }
        },
        handleKeeperChange: (year, index, field, value) => {
          if (window.AppState.locks[year]) return;
          window.AppState.setPendingChanges(prev => {
            const updatedPending = { ...prev, [year]: { ...prev[year], [index]: { ...prev[year][index], [field]: value } } };
            const teamData = { ...window.AppState.keepers[year][index], ...updatedPending[year][index] } || {
              team: `Team ${index + 1}`, keeper1: '', draftCost1: '', tag1: false, cost1: 0,
              keeper2: '', draftCost2: '', tag2: false, cost2: 0, remaining: 200
            };
            if (field === 'draftCost1' || field === 'tag1' || field === 'keeper1') {
              if (field === 'draftCost1') {
                const normalizedValue = window.AppState.normalizeNumberInput(value);
                teamData.draftCost1 = normalizedValue === '' ? '' : parseInt(normalizedValue) || 0;
                updatedPending[year][index].draftCost1 = normalizedValue;
              }
              if (teamData.draftCost1 === '' && value === true) {
                alert('No player can be kept for $0. Untag or set a draft cost.');
                teamData.tag1 = false;
              } else {
                teamData.tag1 = field === 'tag1' ? value : teamData.tag1;
              }
              teamData.cost1 = window.AppState.calculateKeeperCost(teamData.draftCost1 || 0, teamData.tag1, teamData.keeper1);
            }
            if (field === 'draftCost2' || field === 'tag2' || field === 'keeper2') {
              if (field === 'draftCost2') {
                const normalizedValue = window.AppState.normalizeNumberInput(value);
                teamData.draftCost2 = normalizedValue === '' ? '' : parseInt(normalizedValue) || 0;
                updatedPending[year][index].draftCost2 = normalizedValue;
              }
              if (teamData.draftCost2 === '' && value === true) {
                alert('No player can be kept for $0. Untag or set a draft cost.');
                teamData.tag2 = false;
              } else {
                teamData.tag2 = field === 'tag2' ? value : teamData.tag2;
              }
              teamData.cost2 = window.AppState.calculateKeeperCost(teamData.draftCost2 || 0, teamData.tag2, teamData.keeper2);
            }
            teamData.remaining = 200 - (teamData.cost1 + teamData.cost2);
            if (teamData.remaining < 0) {
              alert('Total keeper cost exceeds $200 budget.');
              return prev;
            }
            updatedPending[year][index] = teamData;
            return updatedPending;
          });
        },
        handleSaveRow: async (year, index) => {
          if (window.AppState.locks[year]) return;
          const teamData = window.AppState.pendingChanges[year][index] || window.AppState.keepers[year][index];
          if (!teamData) return;
          const updatedKeepers = { ...window.AppState.keepers };
          updatedKeepers[year][index] = {
            ...window.AppState.keepers[year][index],
            ...teamData,
            draftCost1: teamData.draftCost1 === '' ? 0 : parseInt(teamData.draftCost1) || 0,
            draftCost2: teamData.draftCost2 === '' ? 0 : parseInt(teamData.draftCost2) || 0
          };
          const result = await window.AppState.updateData(`keepers_${year}.json`, updatedKeepers[year], 'update');
          if (result) {
            window.AppState.setKeepers(updatedKeepers);
            window.AppState.setPendingChanges(prev => {
              const updatedPending = { ...prev, [year]: { ...prev[year] } };
              delete updatedPending[year][index];
              return updatedPending;
            });
          }
        },
        initializeKeepers: (year) => {
          if (year === '2025' && window.AppState.keepers[year].length === 0) {
            const initialTeams = Array.from({ length: 12 }, (_, i) => ({
              team: `Team ${i + 1}`, keeper1: '', draftCost1: '', tag1: false, cost1: 0,
              keeper2: '', draftCost2: '', tag2: false, cost2: 0, remaining: 200
            }));
            window.AppState.setKeepers(prev => ({ ...prev, [year]: initialTeams }));
            window.AppState.updateData(`keepers_${year}.json`, initialTeams, 'update');
          }
        },
        handlePayoutChange: async (index, field, value) => {
          if (!window.AppState.isAdminAuthenticated) return;
          const updatedPayouts = [...window.AppState.payouts];
          updatedPayouts[index] = { ...updatedPayouts[index], [field]: field === 'percentage' || field === 'prize' ? parseFloat(value) || 0 : value };
          if (updatedPayouts.some((p, i) => i !== index && p.category === updatedPayouts[index].category)) {
            alert('Category already exists.');
            return;
          }
          const result = await window.AppState.updateData('payouts.json', updatedPayouts, 'update');
          if (result) {
            window.AppState.setPayouts(updatedPayouts);
          }
        },
        handleWeeklyScoreChange: async (year, index, field, value) => {
          if (!window.AppState.isAdminAuthenticated) return;
          const updatedPrizes = { ...window.AppState.prizes };
          const score = { ...updatedPrizes[year].weeklyHighScores[index] };
          score[field] = field === 'total' ? parseFloat(value) || '' : value;
          updatedPrizes[year].weeklyHighScores[index] = score;
          const result = await window.AppState.updateData(`prizes_${year}.json`, updatedPrizes[year], 'update');
          if (result) {
            window.AppState.setPrizes(updatedPrizes);
          }
        },
        handleSurvivorChange: async (year, index, field, value) => {
          if (!window.AppState.isAdminAuthenticated) return;
          const updatedPrizes = { ...window.AppState.prizes };
          const entry = { ...updatedPrizes[year].survivor[index] };
          if (field === 'team') {
            if (index === 11) {
              entry.winner = value;
              entry.eliminated = '';
            } else {
              entry.eliminated = value;
              entry.winner = '';
            }
          }
          updatedPrizes[year].survivor[index] = entry;
          window.AppState.setPrizes(updatedPrizes); // Update state immediately
          const result = await window.AppState.updateData(`prizes_${year}.json`, updatedPrizes[year], 'update');
          if (!result) {
            console.error('Failed to save survivor change, reverting state');
            window.AppState.setPrizes(window.AppState.prizes); // Revert on failure
          }
        },
        getRemainingTeams: (year, currentIndex = -1) => {
          const survivorTeams = window.AppState.prizes[year].survivor
            .filter((entry, index) => currentIndex === -1 || index <= currentIndex)
            .map(entry => entry.eliminated || entry.winner)
            .filter(team => team);
          return window.AppState.keepers[year]
            .map(team => team.team)
            .filter(team => team && !survivorTeams.includes(team))
            .sort();
        },
        handleRuleChange: async (sectionIndex, itemIndex, field, value) => {
          if (!window.AppState.isAdminAuthenticated) return;
          const updatedRules = { ...window.AppState.rules };
          const item = updatedRules.sections[sectionIndex].items[itemIndex];
          if (typeof item === 'string') {
            if (field === 'text') {
              updatedRules.sections[sectionIndex].items[itemIndex] = value;
            }
          } else {
            if (field === 'text') {
              item.text = value;
            } else if (field === 'subItems') {
              item.subItems = value.split('\n').filter(subItem => subItem.trim());
            }
          }
          const result = await window.AppState.updateData('rules.json', updatedRules, 'update');
          if (result) {
            window.AppState.setRules(updatedRules);
          }
        },
      };

      // Ensure window.AppState.prizes is kept in sync whenever setPrizes is called
      (function syncPrizesSetter() {
        const origSetPrizes = setPrizes;
        window.AppState.setPrizes = (value) => {
          if (typeof value === 'function') {
            origSetPrizes(prev => {
              const updated = value(prev);
              window.AppState.prizes = updated;
              return updated;
            });
          } else {
            origSetPrizes(value);
            window.AppState.prizes = value;
          }
        };
      })();

      // Keep payouts and yearlyAwards synced on set as well (so Financials re-renders)
      (function syncPayoutsAndAwards() {
        const origSetPayouts = setPayouts;
        window.AppState.setPayouts = (value) => {
          if (typeof value === 'function') {
            origSetPayouts(prev => {
              const updated = value(prev);
              window.AppState.payouts = updated;
              return updated;
            });
          } else {
            origSetPayouts(value);
            window.AppState.payouts = value;
          }
        };

        const origSetYearlyAwards = setYearlyAwards;
        window.AppState.setYearlyAwards = (value) => {
          if (typeof value === 'function') {
            origSetYearlyAwards(prev => {
              const updated = value(prev);
              window.AppState.yearlyAwards = updated;
              return updated;
            });
          } else {
            origSetYearlyAwards(value);
            window.AppState.yearlyAwards = value;
          }
        };
      })();

      // expose saving flag
      window.AppState.isSaving = isSaving;
      window.AppState.setIsSaving = setIsSaving;

      // Spinner component
      const Spinner = () => (
        <div className="flex items-center justify-center min-h-screen">
          <div className="animate-spin rounded-full h-16 w-16 border-t-4 border-teal-500 border-b-4 border-gray-200"></div>
        </div>
      );

      // Render tab
      const renderTab = () => {
        switch (window.AppState.currentTab) {
          case 'home': return <window.Home />;
          case 'rules': return <window.Rules />;
          case 'payouts': return <window.Payouts />;
          case 'keepers': return <window.Keepers />;
          case 'prizes': return <window.Prizes />;
          case 'financials': return <window.Financials />;
          case 'admin': return <window.Admin />;
          default: return null;
        }
      };

      if (loading) return <Spinner />;

      return (
        <div className="min-h-screen bg-gray-900">
          <nav className="bg-gray-800 text-white p-3 shadow-lg mobile-nav sticky top-0 z-50">
            <div className="container mx-auto flex flex-col sm:flex-row sm:items-center sm:justify-between">
              <div className="flex justify-between items-center w-full sm:w-auto">
                <h1 className="text-xl sm:text-2xl font-bold">FriendZone FF</h1>
                <button
                  className="sm:hidden text-2xl px-2 py-1 focus:outline-none"
                  aria-label="Open menu"
                  onClick={() => window.AppState.setIsMenuOpen(!window.AppState.isMenuOpen)}
                >
                  â˜°
                </button>
              </div>
              <ul className={`sm:flex sm:space-x-4 ${window.AppState.isMenuOpen ? 'block' : 'hidden'} sm:block mt-2 sm:mt-0 p-3 sm:p-0 sm:bg-transparent bg-gray-800 shadow-lg sm:shadow-none`}>
                {['home', 'rules', 'payouts', 'keepers', 'prizes', 'financials', window.AppState.isAdminAuthenticated ? 'logout' : 'admin'].map(tab => (
                  <li key={tab} className="my-2 sm:my-0">
                    <button
                      onClick={() => {
                        if (tab === 'logout') {
                          window.AppState.setIsAdminAuthenticated(false);
                          window.AppState.setAdminPassword('');
                          window.AppState.setCurrentTab('home');
                        } else {
                          window.AppState.setCurrentTab(tab);
                        }
                        window.AppState.setIsMenuOpen(false);
                      }}
                      className={`w-full sm:w-auto text-left capitalize hover:text-teal-400 focus:outline-none px-2 py-2 rounded ${window.AppState.currentTab === tab ? 'text-teal-400 bg-gray-700' : ''}`}
                      style={{ fontSize: '1.1rem' }}
                    >
                      {tab}
                    </button>
                  </li>
                ))}
              </ul>
            </div>
          </nav>
          <main className="container mx-auto pt-16 sm:pt-4 pb-4 px-3 sm:px-4">
            {renderTab()}
            <window.Modal />
          </main>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    // Remove initial spinner when React app is ready
    const removeInitialSpinner = () => {
      const spinner = document.getElementById('initial-spinner');
      if (spinner) spinner.style.display = 'none';
    };
    root.render(<App />);
    removeInitialSpinner();
  </script>
</body>

</html>