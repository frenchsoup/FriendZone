<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FriendZone Fantasy Football League</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/styles.css">
</head>
<body class="bg-gray-900 text-gray-100">
  <div id="root"></div>
  <script src="/sections/modal.html"></script>
  <script src="/sections/home.html"></script>
  <script src="/sections/rules.html"></script>
  <script src="/sections/payouts.html"></script>
  <script src="/sections/keepers.html"></script>
  <script src="/sections/prizes.html"></script>
  <script src="/sections/admin.html"></script>
  <script type="text/babel">
    const App = () => {
      const [currentTab, setCurrentTab] = React.useState('home');
      const [adminPassword, setAdminPassword] = React.useState('');
      const [isAdminAuthenticated, setIsAdminAuthenticated] = React.useState(false);
      const [keepers, setKeepers] = React.useState({ 2022: [], 2023: [], 2024: [], 2025: [] });
      const [prizes, setPrizes] = React.useState({
        2023: { survivor: [], weeklyHighScores: [] },
        2024: { survivor: [], weeklyHighScores: [] },
        2025: {
          survivor: Array.from({ length: 12 }, (_, i) => i < 11 ? { week: i + 1, eliminated: '' } : { week: 12, winner: '' }),
          weeklyHighScores: Array.from({ length: 14 }, (_, i) => ({ week: i + 1, team: '', total: '' }))
        }
      });
      const [rules, setRules] = React.useState({ sections: [] });
      const [payouts, setPayouts] = React.useState([]);
      const [locks, setLocks] = React.useState({ 2022: false, 2023: false, 2024: false, 2025: false });
      const [selectedYear, setSelectedYear] = React.useState('2025');
      const [isMenuOpen, setIsMenuOpen] = React.useState(false);
      const [modalState, setModalState] = React.useState({ isOpen: false, type: '', data: null });
      const [pendingChanges, setPendingChanges] = React.useState({ 2022: {}, 2023: {}, 2024: {}, 2025: {} });

      const ADMIN_PASSWORD = 'friendzone2025';

      // Fetch data
      React.useEffect(() => {
        const fetchData = async () => {
          const files = [
            { path: '/data/rules.json', setter: setRules, default: { sections: [] } },
            { path: '/data/payouts.json', setter: setPayouts, default: [] },
            { path: '/data/keepers_2022.json', setter: (data) => setKeepers(prev => ({ ...prev, 2022: data.map(team => ({
                ...team, draftCost1: Math.round(team.draftCost1 || 0), draftCost2: Math.round(team.draftCost2 || 0),
                cost1: Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)),
                cost2: Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2)),
                remaining: 200 - (Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)) + Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2)))
              })) })), default: [] },
            { path: '/data/keepers_2023.json', setter: (data) => setKeepers(prev => ({ ...prev, 2023: data.map(team => ({
                ...team, draftCost1: Math.round(team.draftCost1 || 0), draftCost2: Math.round(team.draftCost2 || 0),
                cost1: Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)),
                cost2: Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2)),
                remaining: 200 - (Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)) + Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2)))
              })) })), default: [] },
            { path: '/data/keepers_2024.json', setter: (data) => setKeepers(prev => ({ ...prev, 2024: data.map(team => ({
                ...team, draftCost1: Math.round(team.draftCost1 || 0), draftCost2: Math.round(team.draftCost2 || 0),
                cost1: Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)),
                cost2: Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2)),
                remaining: 200 - (Math.round(window.AppState.calculateKeeperCost(team.draftCost1 || 0, team.tag1, team.keeper1)) + Math.round(window.AppState.calculateKeeperCost(team.draftCost2 || 0, team.tag2, team.keeper2)))
              })) })), default: [] },
            { path: '/data/keepers_2025.json', setter: (data) => setKeepers(prev => ({ ...prev, 2025: data })), default: [] },
            { path: '/data/prizes_2023.json', setter: (data) => setPrizes(prev => ({ ...prev, 2023: data })), default: { survivor: [], weeklyHighScores: [] } },
            { path: '/data/prizes_2024.json', setter: (data) => setPrizes(prev => ({ ...prev, 2024: data })), default: { survivor: [], weeklyHighScores: [] } },
            { path: '/data/prizes_2025.json', setter: (data) => setPrizes(prev => {
              const survivor = data.survivor.length > 0 ? data.survivor : Array.from({ length: 12 }, (_, i) => i < 11 ? { week: i + 1, eliminated: '' } : { week: 12, winner: '' });
              const weeklyHighScores = data.weeklyHighScores.length > 0 ? data.weeklyHighScores : Array.from({ length: 14 }, (_, i) => ({ week: i + 1, team: '', total: '' }));
              return { ...prev, 2025: { survivor, weeklyHighScores } };
            }), default: { 
              survivor: Array.from({ length: 12 }, (_, i) => i < 11 ? { week: i + 1, eliminated: '' } : { week: 12, winner: '' }), 
              weeklyHighScores: Array.from({ length: 14 }, (_, i) => ({ week: i + 1, team: '', total: '' })) 
            } },
            { path: '/data/locks.json', setter: setLocks, default: { 2022: false, 2023: false, 2024: false, 2025: false } },
          ];
          for (const file of files) {
            try {
              const res = await fetch(file.path);
              if (res.ok) {
                const data = await res.json();
                file.setter(data);
              } else {
                file.setter(file.default);
                console.warn(`Failed to load ${file.path}. Using default value.`);
              }
            } catch (err) {
              file.setter(file.default);
              console.warn(`Error fetching ${file.path}:`, err);
            }
          }
        };
        fetchData();
      }, []);

      // Share state and handlers globally
      window.AppState = {
        currentTab, setCurrentTab,
        adminPassword, setAdminPassword,
        isAdminAuthenticated, setIsAdminAuthenticated,
        keepers, setKeepers,
        prizes, setPrizes,
        rules, setRules,
        payouts, setPayouts,
        locks, setLocks,
        selectedYear, setSelectedYear,
        isMenuOpen, setIsMenuOpen,
        modalState, setModalState,
        pendingChanges, setPendingChanges,
        ADMIN_PASSWORD: 'friendzone2025',
        calculateKeeperCost: (draftCost, tag, keeperName) => {
          if (keeperName === '' && draftCost === 0) return 0;
          if (draftCost === 0 && !tag) return 5;
          if (draftCost === 0 && tag) return 0;
          if (tag) return Math.round(draftCost);
          return Math.round(draftCost * 1.1 + 5);
        },
        updateData: async (file, data, action, index = null) => {
          try {
            const res = await fetch('/.netlify/functions/update-data', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ file, data, action, index })
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}: ${await res.text()}`);
            return await res.json();
          } catch (err) {
            console.error('Error updating data:', err);
            alert('Failed to update data. Please try again.');
            return null;
          }
        },
        normalizeNumberInput: (value) => {
          if (value === '' || value == null) return '';
          const strValue = String(value).replace(/^0+/, '');
          if (strValue === '') return '';
          const intValue = Math.round(parseFloat(strValue) || 0);
          return intValue.toString();
        },
        handleArrowKey: (e, year, index, field) => {
          if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            const currentValue = parseFloat(e.target.value) || 0;
            const newValue = e.key === 'ArrowUp' ? currentValue + 1 : Math.max(0, currentValue - 1);
            window.AppState.handleKeeperChange(year, index, field, newValue.toString());
          }
        },
        handleAdminLogin: (e) => {
          e.preventDefault();
          if (window.AppState.adminPassword === window.AppState.ADMIN_PASSWORD) {
            window.AppState.setIsAdminAuthenticated(true);
            window.AppState.setCurrentTab('home');
          } else {
            alert('Incorrect password');
          }
        },
        handleToggleLock: async (year) => {
          const updatedLocks = { ...window.AppState.locks, [year]: !window.AppState.locks[year] };
          const result = await window.AppState.updateData('locks.json', updatedLocks, 'update');
          if (result) {
            window.AppState.setLocks(updatedLocks);
            if (updatedLocks[year]) {
              window.AppState.setPendingChanges(prev => ({ ...prev, [year]: {} }));
            }
          }
        },
        handleKeeperChange: (year, index, field, value) => {
          if (window.AppState.locks[year]) return;
          window.AppState.setPendingChanges(prev => {
            const updatedPending = { ...prev, [year]: { ...prev[year], [index]: { ...prev[year][index], [field]: value } } };
            const teamData = { ...window.AppState.keepers[year][index], ...updatedPending[year][index] } || {
              team: `Team ${index + 1}`, keeper1: '', draftCost1: '', tag1: false, cost1: 0,
              keeper2: '', draftCost2: '', tag2: false, cost2: 0, remaining: 200
            };
            if (field === 'draftCost1' || field === 'tag1' || field === 'keeper1') {
              if (field === 'draftCost1') {
                const normalizedValue = window.AppState.normalizeNumberInput(value);
                teamData.draftCost1 = normalizedValue === '' ? '' : parseInt(normalizedValue) || 0;
                updatedPending[year][index].draftCost1 = normalizedValue;
              }
              if (teamData.draftCost1 === '' && value === true) {
                alert('No player can be kept for $0. Untag or set a draft cost.');
                teamData.tag1 = false;
              } else {
                teamData.tag1 = field === 'tag1' ? value : teamData.tag1;
              }
              teamData.cost1 = window.AppState.calculateKeeperCost(teamData.draftCost1 || 0, teamData.tag1, teamData.keeper1);
            }
            if (field === 'draftCost2' || field === 'tag2' || field === 'keeper2') {
              if (field === 'draftCost2') {
                const normalizedValue = window.AppState.normalizeNumberInput(value);
                teamData.draftCost2 = normalizedValue === '' ? '' : parseInt(normalizedValue) || 0;
                updatedPending[year][index].draftCost2 = normalizedValue;
              }
              if (teamData.draftCost2 === '' && value === true) {
                alert('No player can be kept for $0. Untag or set a draft cost.');
                teamData.tag2 = false;
              } else {
                teamData.tag2 = field === 'tag2' ? value : teamData.tag2;
              }
              teamData.cost2 = window.AppState.calculateKeeperCost(teamData.draftCost2 || 0, teamData.tag2, teamData.keeper2);
            }
            teamData.remaining = 200 - (teamData.cost1 + teamData.cost2);
            if (teamData.remaining < 0) {
              alert('Total keeper cost exceeds $200 budget.');
              return prev;
            }
            updatedPending[year][index] = teamData;
            return updatedPending;
          });
        },
        handleSaveRow: async (year, index) => {
          if (window.AppState.locks[year]) return;
          const teamData = window.AppState.pendingChanges[year][index] || window.AppState.keepers[year][index];
          if (!teamData) return;
          const updatedKeepers = { ...window.AppState.keepers };
          updatedKeepers[year][index] = { 
            ...window.AppState.keepers[year][index], 
            ...teamData,
            draftCost1: teamData.draftCost1 === '' ? 0 : parseInt(teamData.draftCost1) || 0,
            draftCost2: teamData.draftCost2 === '' ? 0 : parseInt(teamData.draftCost2) || 0
          };
          const result = await window.AppState.updateData(`keepers_${year}.json`, updatedKeepers[year], 'update');
          if (result) {
            window.AppState.setKeepers(updatedKeepers);
            window.AppState.setPendingChanges(prev => {
              const updatedPending = { ...prev, [year]: { ...prev[year] } };
              delete updatedPending[year][index];
              return updatedPending;
            });
          }
        },
        initializeKeepers: (year) => {
          if (year === '2025' && window.AppState.keepers[year].length === 0) {
            const initialTeams = Array.from({ length: 12 }, (_, i) => ({
              team: `Team ${i + 1}`, keeper1: '', draftCost1: '', tag1: false, cost1: 0,
              keeper2: '', draftCost2: '', tag2: false, cost2: 0, remaining: 200
            }));
            window.AppState.setKeepers(prev => ({ ...prev, [year]: initialTeams }));
            window.AppState.updateData(`keepers_${year}.json`, initialTeams, 'update');
          }
        },
        handlePayoutChange: async (index, field, value) => {
          if (!window.AppState.isAdminAuthenticated) return;
          const updatedPayouts = [...window.AppState.payouts];
          updatedPayouts[index] = { ...updatedPayouts[index], [field]: field === 'percentage' || field === 'prize' ? parseFloat(value) || 0 : value };
          if (updatedPayouts.some((p, i) => i !== index && p.category === updatedPayouts[index].category)) {
            alert('Category already exists.');
            return;
          }
          const result = await window.AppState.updateData('payouts.json', updatedPayouts, 'update');
          if (result) {
            window.AppState.setPayouts(updatedPayouts);
          }
        },
        handleWeeklyScoreChange: async (year, index, field, value) => {
          if (!window.AppState.isAdminAuthenticated) return;
          const updatedPrizes = { ...window.AppState.prizes };
          const score = { ...updatedPrizes[year].weeklyHighScores[index] };
          score[field] = field === 'total' ? parseFloat(value) || '' : value;
          updatedPrizes[year].weeklyHighScores[index] = score;
          const result = await window.AppState.updateData(`prizes_${year}.json`, updatedPrizes[year], 'update');
          if (result) {
            window.AppState.setPrizes(updatedPrizes);
          }
        },
        handleSurvivorChange: async (year, index, field, value) => {
          if (!window.AppState.isAdminAuthenticated) return;
          const updatedPrizes = { ...window.AppState.prizes };
          const entry = { ...updatedPrizes[year].survivor[index] };
          if (field === 'team') {
            if (entry.winner !== undefined) {
              entry.winner = value;
            } else {
              entry.eliminated = value;
            }
          }
          updatedPrizes[year].survivor[index] = entry;
          const result = await window.AppState.updateData(`prizes_${year}.json`, updatedPrizes[year], 'update');
          if (result) {
            window.AppState.setPrizes(updatedPrizes);
          }
        },
        getRemainingTeams: (year) => {
          const survivorTeams = window.AppState.prizes[year].survivor.map(entry => entry.eliminated || entry.winner);
          return window.AppState.keepers[year]
            .map(team => team.team)
            .filter(team => team && !survivorTeams.includes(team))
            .sort();
        },
        handleRuleChange: async (sectionIndex, itemIndex, field, value) => {
          if (!window.AppState.isAdminAuthenticated) return;
          const updatedRules = { ...window.AppState.rules };
          const item = updatedRules.sections[sectionIndex].items[itemIndex];
          if (typeof item === 'string') {
            if (field === 'text') {
              updatedRules.sections[sectionIndex].items[itemIndex] = value;
            }
          } else {
            if (field === 'text') {
              item.text = value;
            } else if (field === 'subItems') {
              item.subItems = value.split('\n').filter(subItem => subItem.trim());
            }
          }
          const result = await window.AppState.updateData('rules.json', updatedRules, 'update');
          if (result) {
            window.AppState.setRules(updatedRules);
          }
        },
      };

      // Render tab
      const renderTab = () => {
        switch (window.AppState.currentTab) {
          case 'home': return <window.Home />;
          case 'rules': return <window.Rules />;
          case 'payouts': return <window.Payouts />;
          case 'keepers': return <window.Keepers />;
          case 'prizes': return <window.Prizes />;
          case 'admin': return <window.Admin />;
          default: return null;
        }
      };

      return (
        <div className="min-h-screen bg-gray-900">
          <nav className="bg-gray-800 text-white p-3 shadow-lg mobile-nav">
            <div className="container mx-auto flex flex-col sm:flex-row sm:items-center sm:justify-between">
              <div className="flex justify-between items-center w-full sm:w-auto">
                <h1 className="text-xl sm:text-2xl font-bold">FriendZone FF</h1>
                <button 
                  className="sm:hidden text-xl focus:outline-none" 
                  onClick={() => window.AppState.setIsMenuOpen(!window.AppState.isMenuOpen)}
                >
                  ☰
                </button>
              </div>
              <ul className={`sm:flex sm:space-x-4 ${window.AppState.isMenuOpen ? 'block' : 'hidden'} sm:block mt-2 sm:mt-0 p-3 sm:p-0 sm:bg-transparent bg-gray-800 shadow-lg sm:shadow-none`}>
                {['home', 'rules', 'payouts', 'keepers', 'prizes', window.AppState.isAdminAuthenticated ? 'logout' : 'admin'].map(tab => (
                  <li key={tab} className="my-2 sm:my-0">
                    <button 
                      onClick={() => {
                        if (tab === 'logout') {
                          window.AppState.setIsAdminAuthenticated(false);
                          window.AppState.setAdminPassword('');
                          window.AppState.setCurrentTab('home');
                        } else {
                          window.AppState.setCurrentTab(tab);
                        }
                        window.AppState.setIsMenuOpen(false);
                      }} 
                      className={`w-full sm:w-auto text-left capitalize hover:text-teal-400 focus:outline-none ${window.AppState.currentTab === tab ? 'text-teal-400' : ''}`}
                    >
                      {tab}
                    </button>
                  </li>
                ))}
              </ul>
            </div>
          </nav>
          <main className="container mx-auto pt-16 sm:pt-4 pb-4 px-3 sm:px-4">
            {renderTab()}
            <window.Modal />
          </main>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>