<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FriendZone Fantasy Football</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link rel="stylesheet" href="/styles.css">
</head>
<body class="bg-gray-900 text-gray-100">
  <div id="root"></div>
  <script type="text/babel">
    const App = () => {
      const [keepers, setKeepers] = React.useState({});
      const [prizes, setPrizes] = React.useState({});
      const [locks, setLocks] = React.useState({});
      const [rules, setRules] = React.useState({ sections: [] });
      const [payouts, setPayouts] = React.useState([]);
      const [pendingChanges, setPendingChanges] = React.useState({ keepers: {}, prizes: {} });
      const [selectedYear, setSelectedYear] = React.useState('2025');
      const [isAdminAuthenticated, setIsAdminAuthenticated] = React.useState(false);
      const [view, setView] = React.useState('home');
      const [modalState, setModalState] = React.useState({ isOpen: false, type: '', data: {} });

      const initializeData = async (year) => {
        try {
          const baseUrl = '/.netlify/functions/get-data?filename=';
          if (!keepers[year]) {
            const response = await fetch(`${baseUrl}keepers_${year}.json`);
            let data = {};
            if (response.ok) {
              data = await response.json();
              console.log(`Keepers data for ${year}:`, data);
            } else {
              console.warn(`Failed to fetch keepers_${year}.json, status: ${response.status}`);
            }
            setKeepers(prev => ({
              ...prev,
              [year]: (data.teams && Array.isArray(data.teams) && data.teams.length > 0)
                ? data.teams
                : Array(12).fill().map((_, i) => ({
                    team: `Team ${i + 1}`,
                    keeper1: '', draftCost1: 0, tag1: false, cost1: 0,
                    keeper2: '', draftCost2: 0, tag2: false, cost2: 0,
                    remaining: 200,
                  })),
            }));
          }
          if (!prizes[year]) {
            const response = await fetch(`${baseUrl}prizes_${year}.json`);
            let data = {};
            if (response.ok) {
              data = await response.json();
              console.log(`Prizes data for ${year}:`, data);
            } else {
              console.warn(`Failed to fetch prizes_${year}.json, status: ${response.status}`);
            }
            setPrizes(prev => ({
              ...prev,
              [year]: (data.weeklyHighScores && data.survivor)
                ? data
                : {
                    weeklyHighScores: Array(17).fill().map((_, i) => ({
                      week: i + 1,
                      team: '',
                      total: '',
                    })),
                    survivor: Array(12).fill().map((_, i) => ({
                      week: i + 1,
                      eliminated: '',
                      winner: i === 11 ? '' : undefined,
                    })),
                  },
            }));
          }
          if (!locks[year]) {
            const response = await fetch(`${baseUrl}locks.json`);
            let data = {};
            if (response.ok) {
              data = await response.json();
              console.log('Locks data:', data);
            } else {
              console.warn(`Failed to fetch locks.json, status: ${response.status}`);
            }
            setLocks(data || { [year]: false });
          }
          if (!rules.sections.length) {
            const response = await fetch(`${baseUrl}rules.json`);
            let data = {};
            if (response.ok) {
              data = await response.json();
              console.log('Rules data:', data);
            } else {
              console.warn(`Failed to fetch rules.json, status: ${response.status}`);
            }
            setRules(data.sections ? data : { sections: [] });
          }
          if (!payouts.length) {
            const response = await fetch(`${baseUrl}payouts.json`);
            let data = [];
            if (response.ok) {
              data = await response.json();
              console.log('Payouts data:', data);
            } else {
              console.warn(`Failed to fetch payouts.json, status: ${response.status}`);
            }
            setPayouts(Array.isArray(data) ? data : []);
          }
        } catch (error) {
          console.error('Error initializing data:', error);
        }
      };

      const handleKeeperChange = (year, index, field, value) => {
        const updatedPending = { ...pendingChanges };
        updatedPending.keepers[year] = updatedPending.keepers[year] || {};
        updatedPending.keepers[year][index] = {
          ...updatedPending.keepers[year][index],
          ...keepers[year][index],
          [field]: value,
        };
        setPendingChanges(updatedPending);
      };

      const handleSaveRow = async (year, index) => {
        const updatedKeepers = { ...keepers };
        const pending = pendingChanges.keepers[year]?.[index] || {};
        const team = { ...updatedKeepers[year][index], ...pending };
        const cost1 = team.tag1 ? (parseInt(team.draftCost1) || 0) + 5 : parseInt(team.draftCost1) || 0;
        const cost2 = team.tag2 ? (parseInt(team.draftCost2) || 0) + 5 : parseInt(team.draftCost2) || 0;
        if ((team.tag1 && !team.draftCost1) || (team.tag2 && !team.draftCost2)) {
          alert('Tagged keepers must have a draft cost greater than 0');
          return;
        }
        team.cost1 = cost1;
        team.cost2 = cost2;
        team.remaining = 200 - cost1 - cost2;
        updatedKeepers[year][index] = team;
        const result = await updateData(`keepers_${year}.json`, updatedKeepers[year], 'update');
        if (result) {
          setKeepers(updatedKeepers);
          const updatedPending = { ...pendingChanges };
          updatedPending.keepers[year][index] = {};
          setPendingChanges(updatedPending);
        }
      };

      const handleWeeklyScoreChange = (year, index, field, value) => {
        if (!isAdminAuthenticated) return;
        const updatedPending = { ...pendingChanges };
        updatedPending.prizes[year] = updatedPending.prizes[year] || {};
        updatedPending.prizes[year].weeklyHighScores = updatedPending.prizes[year].weeklyHighScores || [];
        updatedPending.prizes[year].weeklyHighScores[index] = {
          ...updatedPending.prizes[year].weeklyHighScores[index],
          ...prizes[year].weeklyHighScores[index],
          [field]: value,
        };
        setPendingChanges(updatedPending);
      };

      const handleWeeklyScoreSave = async (year, index) => {
        if (!isAdminAuthenticated) return;
        const updatedPrizes = { ...prizes };
        updatedPrizes[year].weeklyHighScores[index] = {
          ...updatedPrizes[year].weeklyHighScores[index],
          ...pendingChanges.prizes[year]?.weeklyHighScores[index],
        };
        const result = await updateData(`prizes_${year}.json`, updatedPrizes[year], 'update');
        if (result) {
          setPrizes(updatedPrizes);
          const updatedPending = { ...pendingChanges };
          updatedPending.prizes[year].weeklyHighScores[index] = {};
          setPendingChanges(updatedPending);
        } else {
          console.error('Failed to save weekly score');
        }
      };

      const handleSurvivorChange = (year, index, field, value) => {
        if (!isAdminAuthenticated) return;
        const updatedPending = { ...pendingChanges };
        updatedPending.prizes[year] = updatedPending.prizes[year] || {};
        updatedPending.prizes[year].survivor = updatedPending.prizes[year].survivor || [];
        updatedPending.prizes[year].survivor[index] = {
          ...updatedPending.prizes[year].survivor[index],
          ...prizes[year].survivor[index],
          [index === 11 ? 'winner' : 'eliminated']: value,
          [index === 11 ? 'eliminated' : 'winner']: '',
        };
        setPendingChanges(updatedPending);
      };

      const handleSurvivorSave = async (year, index) => {
        if (!isAdminAuthenticated) return;
        const updatedPrizes = { ...prizes };
        updatedPrizes[year].survivor[index] = {
          ...updatedPrizes[year].survivor[index],
          ...pendingChanges.prizes[year]?.survivor[index],
        };
        const result = await updateData(`prizes_${year}.json`, updatedPrizes[year], 'update');
        if (result) {
          setPrizes(updatedPrizes);
          const updatedPending = { ...pendingChanges };
          updatedPending.prizes[year].survivor[index] = {};
          setPendingChanges(updatedPending);
        } else {
          console.error('Failed to save survivor change');
        }
      };

      const handleRuleChange = async (sectionIndex, itemIndex, field, value) => {
        if (!isAdminAuthenticated) return;
        const updatedRules = { ...rules };
        const item = updatedRules.sections[sectionIndex].items[itemIndex];
        if (field === 'subItems') {
          updatedRules.sections[sectionIndex].items[itemIndex] = {
            ...item,
            subItems: value.split('\n').filter(line => line.trim()),
          };
        } else {
          if (typeof item === 'string') {
            updatedRules.sections[sectionIndex].items[itemIndex] = value;
          } else {
            updatedRules.sections[sectionIndex].items[itemIndex] = { ...item, [field]: value };
          }
        }
        const result = await updateData('rules.json', updatedRules, 'update');
        if (result) setRules(updatedRules);
      };

      const handleAddSection = async () => {
        if (!isAdminAuthenticated) return;
        const newSection = { title: 'New Section', items: ['New Rule'] };
        const updatedRules = { sections: [...rules.sections, newSection] };
        const result = await updateData('rules.json', updatedRules, 'update');
        if (result) setRules(updatedRules);
      };

      const handleAddRule = async (sectionIndex) => {
        if (!isAdminAuthenticated) return;
        const updatedRules = { ...rules };
        updatedRules.sections[sectionIndex].items.push('New Rule');
        const result = await updateData('rules.json', updatedRules, 'update');
        if (result) setRules(updatedRules);
      };

      const handleSectionTitleChange = async (sectionIndex, value) => {
        if (!isAdminAuthenticated) return;
        const updatedRules = { ...rules };
        updatedRules.sections[sectionIndex].title = value;
        const result = await updateData('rules.json', updatedRules, 'update');
        if (result) setRules(updatedRules);
      };

      const handleDeleteSection = async (sectionIndex) => {
        if (!isAdminAuthenticated) return;
        const updatedRules = {
          sections: rules.sections.filter((_, index) => index !== sectionIndex),
        };
        const result = await updateData('rules.json', updatedRules, 'update');
        if (result) {
          setRules(updatedRules);
          setModalState({ isOpen: false, type: '', data: {} });
        }
      };

      const handleDeleteRule = async (sectionIndex, itemIndex) => {
        if (!isAdminAuthenticated) return;
        const updatedRules = { ...rules };
        updatedRules.sections[sectionIndex].items = updatedRules.sections[sectionIndex].items.filter(
          (_, index) => index !== itemIndex
        );
        const result = await updateData('rules.json', updatedRules, 'update');
        if (result) {
          setRules(updatedRules);
          setModalState({ isOpen: false, type: '', data: {} });
        }
      };

      const handlePayoutChange = async (index, field, value) => {
        if (!isAdminAuthenticated) return;
        const updatedPayouts = [...payouts];
        updatedPayouts[index] = { ...updatedPayouts[index], [field]: value };
        const result = await updateData('payouts.json', updatedPayouts, 'update');
        if (result) setPayouts(updatedPayouts);
      };

      const handleAddPayout = async () => {
        if (!isAdminAuthenticated) return;
        const newPayout = { category: 'New Category', percentage: 0, prize: 0 };
        const updatedPayouts = [...payouts, newPayout];
        const result = await updateData('payouts.json', updatedPayouts, 'update');
        if (result) setPayouts(updatedPayouts);
      };

      const handleDeletePayout = async (index) => {
        if (!isAdminAuthenticated) return;
        const updatedPayouts = payouts.filter((_, i) => i !== index);
        const result = await updateData('payouts.json', updatedPayouts, 'delete', index);
        if (result) setPayouts(updatedPayouts);
      };

      const updateData = async (filename, data, action, index) => {
        try {
          const response = await fetch('/.netlify/functions/update-data', {
            method: 'POST',
            body: JSON.stringify({ file: filename, data, action, index }),
          });
          return response.ok;
        } catch (error) {
          console.error('Error updating data:', error);
          return false;
        }
      };

      const getRemainingTeams = (year, currentIndex = -1) => {
        const survivorTeams = prizes[year]?.survivor
          ?.filter((entry, index) => currentIndex === -1 || index <= currentIndex)
          .map(entry => entry.eliminated || entry.winner)
          .filter(team => team) || [];
        return keepers[year]
          ?.map(team => team.team)
          .filter(team => team && !survivorTeams.includes(team))
          .sort() || [];
      };

      const handleToggleLock = async (year) => {
        if (!isAdminAuthenticated) return;
        const updatedLocks = { ...locks, [year]: !locks[year] };
        const result = await updateData('locks.json', updatedLocks, 'update');
        if (result) setLocks(updatedLocks);
      };

      const handleArrowKey = (e, year, index, field) => {
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
          e.preventDefault();
          const newIndex = e.key === 'ArrowUp' ? index - 1 : index + 1;
          if (newIndex >= 0 && newIndex < keepers[year].length) {
            const input = document.querySelector(`input[name="${field}-${newIndex}"]`);
            if (input) input.focus();
          }
        }
      };

      const handleAdminLogin = (e) => {
        e.preventDefault();
        const password = e.target.querySelector('#password').value;
        if (password === 'friendzone2025') {
          setIsAdminAuthenticated(true);
          alert('Login successful!');
        } else {
          alert('Incorrect password');
        }
      };

      const handleLogout = () => {
        setIsAdminAuthenticated(false);
        alert('Logged out');
      };

      React.useEffect(() => {
        initializeData(selectedYear);
      }, [selectedYear]);

      const Modal = () => {
        if (!modalState.isOpen) return null;
        const { type, data } = modalState;
        return (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white rounded-lg p-6 w-full max-w-md">
              <h3 className="text-lg font-bold mb-4">
                {type === 'deleteSection' ? 'Delete Section' : 'Delete Rule'}
              </h3>
              <p className="text-sm mb-4">
                Are you sure you want to delete this {type === 'deleteSection' ? 'section' : 'rule'}?
              </p>
              <div className="flex justify-end space-x-2">
                <button
                  onClick={() => setModalState({ isOpen: false, type: '', data: {} })}
                  className="px-4 py-2 text-sm bg-gray-500 text-white rounded hover:bg-gray-600"
                >
                  Cancel
                </button>
                <button
                  onClick={() => {
                    if (type === 'deleteSection') handleDeleteSection(data.sectionIndex);
                    if (type === 'deleteRule') handleDeleteRule(data.sectionIndex, data.itemIndex);
                  }}
                  className="px-4 py-2 text-sm bg-red-500 text-white rounded hover:bg-red-600"
                >
                  Delete
                </button>
              </div>
            </div>
          </div>
        );
      };

      return (
        <div className="min-h-screen">
          <nav className="bg-gray-800 p-4 flex justify-between items-center">
            <div className="flex space-x-4">
              <a href="#" onClick={() => setView('home')} className="text-white hover:text-teal-400">Home</a>
              <a href="#" onClick={() => setView('rules')} className="text-white hover:text-teal-400">Rules</a>
              <a href="#" onClick={() => setView('payouts')} className="text-white hover:text-teal-400">Payouts</a>
              <a href="#" onClick={() => setView('keepers')} className="text-white hover:text-teal-400">Keepers</a>
              <a href="#" onClick={() => setView('prizes')} className="text-white hover:text-teal-400">Prizes</a>
              {isAdminAuthenticated && (
                <a href="#" onClick={() => setView('admin')} className="text-white hover:text-teal-400">Admin</a>
              )}
            </div>
            <div>
              {!isAdminAuthenticated ? (
                <button onClick={() => setView('admin')} className="text-white hover:text-teal-400">Login</button>
              ) : (
                <button onClick={handleLogout} className="text-white hover:text-teal-400">Logout</button>
              )}
            </div>
          </nav>
          <main className="px-4 sm:px-6 py-4">
            {view === 'home' && window.Home && <window.Home />}
            {view === 'rules' && window.Rules && <window.Rules
              rules={rules}
              setRules={setRules}
              isAdminAuthenticated={isAdminAuthenticated}
              updateData={updateData}
              handleRuleChange={handleRuleChange}
              handleAddSection={handleAddSection}
              handleAddRule={handleAddRule}
              handleSectionTitleChange={handleSectionTitleChange}
              setModalState={setModalState}
            />}
            {view === 'payouts' && window.Payouts && <window.Payouts
              payouts={payouts}
              setPayouts={setPayouts}
              isAdminAuthenticated={isAdminAuthenticated}
              updateData={updateData}
              handlePayoutChange={handlePayoutChange}
              handleAddPayout={handleAddPayout}
              handleDeletePayout={handleDeletePayout}
            />}
            {view === 'keepers' && window.Keepers && <window.Keepers
              keepers={keepers}
              locks={locks}
              selectedYear={selectedYear}
              setSelectedYear={setSelectedYear}
              pendingChanges={pendingChanges}
              isAdminAuthenticated={isAdminAuthenticated}
              handleToggleLock={handleToggleLock}
              initializeData={initializeData}
              handleKeeperChange={handleKeeperChange}
              handleSaveRow={handleSaveRow}
              handleArrowKey={handleArrowKey}
            />}
            {view === 'prizes' && window.Prizes && <window.Prizes
              prizes={prizes}
              keepers={keepers}
              selectedYear={selectedYear}
              setSelectedYear={setSelectedYear}
              isAdminAuthenticated={isAdminAuthenticated}
              pendingChanges={pendingChanges}
              handleWeeklyScoreChange={handleWeeklyScoreChange}
              handleWeeklyScoreSave={handleWeeklyScoreSave}
              handleSurvivorChange={handleSurvivorChange}
              handleSurvivorSave={handleSurvivorSave}
              getRemainingTeams={getRemainingTeams}
            />}
            {view === 'admin' && window.Admin && <window.Admin
              handleAdminLogin={handleAdminLogin}
            />}
          </main>
          <Modal />
        </div>
      );
    };

    const checkComponentsLoaded = setInterval(() => {
      if (window.Home && window.Rules && window.Payouts && window.Keepers && window.Prizes && window.Admin) {
        clearInterval(checkComponentsLoaded);
        ReactDOM.render(<App />, document.getElementById('root'));
      }
    }, 100);
  </script>
  <script src="/sections/home.js" type="text/babel"></script>
  <script src="/sections/rules.js" type="text/babel"></script>
  <script src="/sections/payouts.js" type="text/babel"></script>
  <script src="/sections/keepers.js" type="text/babel"></script>
  <script src="/sections/prizes.js" type="text/babel"></script>
  <script src="/sections/admin.js" type="text/babel"></script>
</body>
</html>